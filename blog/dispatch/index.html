<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/styles/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/hypertext.css"> <link rel=icon  href="/assets/favicon.png"> <title>Julia's multple dispatch</title> <header> <h1 style="color:#283747">Shane Chu</h1> <nav> <a href="/" class=current >About</a> | <a href="/research">Research</a> | <a href="/blog">Notes</a> | <a href="/tags/">Tags</a> | <a href="/Shane_CV.pdf">CV</a> | <a href="/others">Others</a> <hr/> </nav> </header> <div class=franklin-content ><h2 id=julias_multple_dispatch ><a href="#julias_multple_dispatch" class=header-anchor >Julia&#39;s multple dispatch</a></h2> <p>I&#39;ve been using Julia for programming since graduate school, and most of the time I just &quot;go with the flow&quot; - never really thinking deeply about the reasons why I use Julia. It was perhaps only with a sense of nice syntax, speed, and a package management system that usually gave me much less headache compared to Python.</p> <p>But recently I have more appreciation for multiple dispatch. When the codebase becomes large, naturally there will be certain behaviors that distinct groups of objects need to define. Combined with duck typing, this becomes quite powerful. For example, I can have a function that defines behavior for a primitive type and another function that defines behavior for my user-defined type. Sometimes the user-defined type resides in another package, and it can become messy and hard to maintain down the road if I want to add package dependencies to the current working package. The solution then is to define a function for the primitive type first, and let the duck typing approach specify what other packages require when they extend the behavior.</p> <h3 id=solution_to_my_problem ><a href="#solution_to_my_problem" class=header-anchor >Solution to my problem</a></h3> <p>For example, I can design the interface in my base package:</p> <pre><code class="julia hljs"><span class=hljs-comment ># In my base package - no external dependencies</span>
extract_features(x::<span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Int</span>}) = tuple(x...)

<span class=hljs-comment ># Duck typing fallback for any iterable with feature_index</span>
extract_features(data) = tuple(item.feature_index <span class=hljs-keyword >for</span> item <span class=hljs-keyword >in</span> data)</code></pre> <p>The first function <code>extract_features&#40;x::Vector&#123;Int&#125;&#41;</code> specializes. The second function is used for the more general &quot;duck typing&quot; case. This way, I do not have to make the dependency of another package – I just have to assume the object has the required property <code>feature_index</code>. This is nice, as I now don&#39;t have to worry about the unnecessary coupling of different packages.</p> <h3 id=its_easier_to_code_interaction_behavior_with_multiple_dispatch ><a href="#its_easier_to_code_interaction_behavior_with_multiple_dispatch" class=header-anchor >It&#39;s easier to code interaction behavior with multiple dispatch </a></h3> <p>To consider the difference between single dispatch and multiple dispatch, consider Python which by default uses single dispatch. Here&#39;s an example with a <code>Car</code> class:</p> <pre><code class="julia hljs">class Car:
    def drive(self, road):
        <span class=hljs-keyword >if</span> isinstance(road, IceRoad):
            <span class=hljs-keyword >return</span> <span class=hljs-string >&quot;slipping and sliding&quot;</span>
        elif isinstance(road, RaceTrack):
            <span class=hljs-keyword >return</span> <span class=hljs-string >&quot;zooming at high speed&quot;</span>
        <span class=hljs-keyword >else</span>:
            <span class=hljs-keyword >return</span> <span class=hljs-string >&quot;driving normally&quot;</span></code></pre> <p>Here the <code>drive</code> method only dispatches on self &#40;the <code>Car</code>&#41;, so I have to manually check the type of road and handle each case with isinstance checks. If I want different cars to behave differently on the same road, I&#39;d need separate classes with their own type checking logic.</p> <p>But in Julia with multiple dispatch:</p> <pre><code class="julia hljs">drive(car::Car, road::IceRoad) = <span class=hljs-string >&quot;slipping and sliding&quot;</span>
drive(car::Car, road::RaceTrack) = <span class=hljs-string >&quot;zooming at high speed&quot;</span> 
drive(car::Car, road::Road) = <span class=hljs-string >&quot;driving normally&quot;</span>

<span class=hljs-comment ># Easy to add new car types without modifying existing code</span>
drive(car::SportsCar, road::RaceTrack) = <span class=hljs-string >&quot;blazing past everyone&quot;</span>
drive(car::Truck, road::IceRoad) = <span class=hljs-string >&quot;steady with chains on&quot;</span></code></pre> <p>This localized behavior on the interactions among different objects makes the code much more manageable – I don&#39;t have to look at each object&#39;s blueprint, which itself is a noisy process, e.g. navigating the subroutines, create another <code>elif</code>, etc. There&#39;s also the benefit of <strong>seeing the big picture</strong> – the interactions can be concentrated altogether in a single code file. </p> <p>There are other benefits too – like the <strong>extensibility without modifying old code</strong>. I can just define new methods for new types without touching anything that already works. And performance-wise, Julia compiles specialized versions for each type combination, so I avoid all the runtime type checking and branching that comes with traditional object-oriented approaches.</p> <div class=page-foot > Contact me by <a href="mailto:sc5502@cumc.columbia.edu">E-mail</a> | <a href="https://github.com/kchu25">Github</a> | <a href="https://www.linkedin.com/in/kchu1/">Linkedin</a> <br> This work is licensed under <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a>. Last modified: September 27, 2025. <br> Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia language</a>. </div> </div> <script src="/libs/highlight/highlight.min.js"></script> <script>hljs.highlightAll();hljs.configure({tabReplace: ' '});</script>